/*
 *  OpenDBX - A simple but extensible database abstraction layer
 *  Copyright (C) 2004-2008 Norbert Sendetzky <norbert@linuxnetworks.de>
 *
 *  This library is free software; you can redistribute it and/or
 *  modify it under the terms of the GNU Library General Public
 *  License as published by the Free Software Foundation; either
 *  version 2 of the License, or (at your option) any later version.
 *
 *  This library is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 *  Library General Public License for more details.
 *
 *  You should have received a copy of the GNU Library General Public
 *  License along with this library; if not, write to the Free
 *  Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
 *  02111-1307 USA.
 */



#include <opendbx/api.h>
#include <stdexcept>
#include <vector>
#include <string>



#ifndef ODBX_API_HPP
#define ODBX_API_HPP



extern "C++" {



namespace OpenDBX
{
	using std::string;

	class Lob_Iface;
	class Result_Iface;
	class Stmt_Iface;
	class Conn_Iface;



	/**
	 * Exception thrown by OpenDBX objects.
	 * Most calls to methods of OpenDBX objects does throw an exception in case
	 * an error occurs in the underlying database library. Additionally to other
	 * exceptions which inherit from the STL exception class it will not only
	 * contain a translated error message depending on the user settings but
	 * also a machine readable error code and an indicator for the severity of
	 * the eror.
	 *
	 * @author Norbert Sendetzky <norbert@linuxnetworks.de>
	 * @version 1.0
	 */
	class Exception : public std::runtime_error
	{
		/**
		 * Error code (negative).
		 */
		int m_error;

		/**
		 * Severity of error (negative: fatal, zero: success, positive: warning)
		 */
		int m_type;

	public:

		/**
		 * Initializes the exception object.
		 * The first parameter, the error message, should be the human readable
		 * description of what has gone wrong. It should also be already translated
		 * to the language of the user which depends on his environment settings
		 * when e.g GNU gettext is used. Errors thrown by the OpenDBX C++ library
		 * are already translated.
		 * The OpenDBX error code is the machine readable code for the error which
		 * has been occured.
		 * The last parameter must be a value indicating the severity of the
		 * thrown error. If the value is smaller than zero, the error is fatal
		 * and the connection to the database can't be recovered and has to be
		 * closed and reopened before the application can try to continue.
		 *
		 * @param msg Human readable error message
		 * @param err OpenDBX error code
		 * @param type Severity of error (negative: fatal, zero: success, positive: warning)
		 * @return Exception
		 */
		Exception( const string& msg, int err, int type ) throw();

		/**
		 * Returns the OpenDBX error code related to the error.
		 * The machine readable code describing the error which occured can be
		 * used by the application to act differently depending on the specific
		 * error.
		 *
		 * @return Error code
		 */
		int getCode() const throw();

		/**
		 * Returns severity indicator.
		 * The returned value classifies the error thrown. In case it is negative,
		 * the error is fatal (e.g. the connection to the database is lost) and
		 * the application can't continue without closing and reopening the
		 * connection.
		 * If the value is positive, the database wasn't able to perform the
		 * requested action but the connection is still OK and can be used to
		 * send more requests to the database.
		 * On zero, everything was successfull and no error occured. This
		 * shouldn't happen when catching one of these exceptions.
		 *
		 * @return Severity of error (negative: fatal, zero: success, positive: warning)
		 */
		int getType() const throw();
	};



	/**
	 * Handling large objects if supported by the database.
	 *
	 * @author Norbert Sendetzky <norbert@linuxnetworks.de>
	 * @version 1.0
	 */
	class Lob
	{
		friend class Result;

		/**
		 * Private implementation of object.
		 */
		Lob_Iface* m_impl;

		/**
		 * Reference counter of copies.
		 */
		int* m_ref;

	protected:

		/**
		 * Default constructor.
		 *
		 * The default constructor isn't part of the public interface as the
		 * object must not be created manually. Instead, the Result::getLob()
		 * method is a factory for instances of the large object class.
		 *
		 * @return Lob instance
		 */
		Lob() throw() {};

		/**
		 * Create large object instance.
		 *
		 * The constructor isn't part of the public interface as the object must
		 * not be created manually. Instead, the Result::getLob()  method is a
		 * factory for instances of the large object class.
		 *
		 * @param impl Pointer to private implementation
		 * @return Lob instance
		 * @throws std::exception If an error occures
		 */
		Lob( Lob_Iface* impl ) throw( std::exception );

	public:

		/**
		 * Destroy large object instance if no other references exist.
		 *
		 * Each large object uses a reference counter to remember if the
		 * internal variables are shared with other objects. If this isn't the
		 * case or if this object is the last one referencing the variables,
		 * the object is cleanup up and the allocated memory freed.
		 */
		~Lob() throw();

		/**
		 * Copy constructor.
		 *
		 * Enables the transfer of the internal state of an object of the same
		 * type to this object. Both objects share the same variables
		 * and the reference counter afterwards. The reference counter is
		 * incremented each time an object is copied and will be decremented if
		 * it is destroyed.
		 *
		 * @param ref Original large object instance
		 */
		Lob( const Lob& ref ) throw();

		/**
		 * Assign large object instance to another one.
		 *
		 * Assigns the internal state of an object of the same type to this
		 * object. Both objects share the same variables and the
		 * reference counter afterwards. The reference counter is incremented
		 * each time an object is copied and will be decremented if it is
		 * destroyed.
		 *
		 * @param ref Large object instance
		 * @return Large object reference of this instance
		 */
		Lob& operator=( const Lob& ref ) throw();

		/**
		 * Closes the large object and commits the changes.
		 *
		 * After reading from or writing new content into the large object, it
		 * should be closed to commit changes to the disk and clean up the
		 * resources. If this isn't done, the destructor of the object tries to
		 * close the large object automatically, but there's no guarantee it
		 * was successful as the destructor doesn't throw an exception in case
		 * of an error. Therefore, it's highly recommended to call this method
		 * once when you don't need the object any more.
		 *
		 * @throws OpenDBX::Exception If the underlying database library returns an error
		 */
		void close() throw( std::exception );

		/**
		 * Reads content from large object into the buffer.
		 *
		 * @param buffer Pointer to a byte array where the data should be written to
		 * @param buflen Length of the given buffer in bytes
		 * @return Number of bytes written into the buffer
		 * @throws OpenDBX::Exception If the underlying database library returns an error
		 */
		ssize_t read( void* buffer, size_t buflen ) throw( std::exception );

		/**
		 * Writes data from the buffer into the large object.
		 *
		 * @param buffer Pointer to a byte array where the content is stored
		 * @param buflen Length of the data in the buffer in bytes
		 * @return Number of bytes written into the large object
		 * @throws OpenDBX::Exception If the underlying database library returns an error
		 */
		ssize_t write( void* buffer, size_t buflen ) throw( std::exception );
	};



	/**
	 * Provides result sets from the database.
	 *
	 * @author Norbert Sendetzky <norbert@linuxnetworks.de>
	 * @version 1.0
	 */
	class Result
	{
		friend class Stmt;

		/**
		 * Private implementation of object.
		 */
		Result_Iface* m_impl;

		/**
		 * Reference counter of copies.
		 */
		int* m_ref;

	protected:

		/**
		 * Default constructor.
		 *
		 * The default constructor isn't part of the public interface as the
		 * object must not be created manually. Instead, the Stmt::execute()
		 * method is a factory for instances of the Result class.
		 *
		 * @return Result instance
		 */
		Result() throw() {};

		/**
		 * Creates a Result instance.
		 *
		 * The constructor isn't part of the public interface as the object must
		 * not be created manually. Instead, the Stmt::execute()  method is a
		 * factory for instances of the Result class.
		 *
		 * @param impl Pointer to private implementation
		 * @throws std::exception If an error occures
		 * @return Result instance
		 */
		Result( Result_Iface* impl ) throw( std::exception );

	public:

		/**
		 * Destroys a Result instance if no other references exist.
		 *
		 * Each result object uses a reference counter to remember if the
		 * internal variables are shared with other objects. If this isn't the
		 * case or if this object is the last one referencing the variables,
		 * the object is cleanup up and the allocated memory freed.
		 */
		~Result() throw();

		/**
		 * Copy constructor.
		 *
		 * Enables the transfer of the internal state of an object of the same
		 * type to this object. Both objects share the same variables
		 * and the reference counter afterwards. The reference counter is
		 * incremented each time an object is copied and will be decremented if
		 * it is destroyed.
		 *
		 * @param ref Original result object instance
		 */
		Result( const Result& ref ) throw();

		/**
		 * Assigns a Result instance to another one.
		 *
		 * Assigns the internal state of an object of the same type to this
		 * object. Both objects share the same variables and the
		 * reference counter afterwards. The reference counter is incremented
		 * each time an object is copied and will be decremented if it is
		 * destroyed.
		 *
		 * @param ref Result instance
		 * @return Result reference of this instance
		 */
		Result& operator=( const Result& ref ) throw();

		/**
		 * Retrieves unfetched rows and cleans up the available result sets.
		 *
		 * After executing a statement, at least one result set is returned by
		 * the database server. In case of data manipulation statements, there
		 * are no rows returned but you have to clean up the result set
		 * nevertheless. This is usually done by calling and getResult() in a loop
		 * until it returns "done". In order to simplify application development,
		 * the finish() method does this for you.
		 *
		 * @throws OpenDBX::Exception If the underlying database library returns an error
		 */
		void finish() throw( std::exception );

		/**
		 * Fetches one result set from the database server.
		 *
		 * @param timeout Pointer to a timeval struct specifying how long to wait for a result set from the database server
		 * @param chunk Number of rows to fetch at once from the database server (zero means all rows at once)
		 * @return Status or error code
		 * @throws OpenDBX::Exception If the underlying database library returns an error
		 * @see odbxres
		 */
		odbxres getResult( struct timeval* timeout = NULL, unsigned long chunk = 0 ) throw( std::exception );

		/**
		 * Makes data of next row available.
		 *
		 * @return Status or error code
		 * @throws OpenDBX::Exception If the underlying database library returns an error
		 */
		odbxrow getRow() throw( std::exception );

		/**
		 * Returns the number of rows affected by DELETE, INSERT of UPDATE statements.
		 *
		 * @return Number of rows touched
		 * @throws OpenDBX::Exception If the underlying database library returns an error
		 */
		uint64_t rowsAffected() throw( std::exception );

		/**
		 * Returns the number of columns available in this result set.
		 *
		 * @return Number of columns
		 * @throws OpenDBX::Exception If the underlying database library returns an error
		 */
		unsigned long columnCount() throw( std::exception );

		/**
		 * Maps the column name to the column number required by other methods.
		 *
		 * @param name Name of the column in the result set
		 * @return Position of column in result set
		 * @throws OpenDBX::Exception If the underlying database library returns an error
		 */
		unsigned long columnPos( const string& name ) throw( std::exception );

		/**
		 * Returns the name of the column in the current result set.
		 *
		 * @param pos Position of column in result set
		 * @return Column name
		 * @throws OpenDBX::Exception If the underlying database library returns an error
		 */
		const string columnName( unsigned long pos ) throw( std::exception );

		/**
		 * Returns the type of the column in the current result set.
		 *
		 * @param pos Position of column in result set
		 * @return Column type
		 * @throws OpenDBX::Exception If the underlying database library returns an error
		 * @see odbxtype
		 */
		odbxtype columnType( unsigned long pos ) throw( std::exception );

		/**
		 * Returns the size of the content in the current row at the specified postion.
		 *
		 * @param pos Position of column in result set
		 * @return Size of the data in bytes
		 * @throws OpenDBX::Exception If the underlying database library returns an error
		 */
		unsigned long fieldLength( unsigned long pos ) throw( std::exception );

		/**
		 * Returns a pointer to the content in the current row at the specified postion.
		 *
		 * @param pos Position of column in result set
		 * @return Pointer to the data
		 * @throws OpenDBX::Exception If the underlying database library returns an error
		 */
		const char* fieldValue( unsigned long pos ) throw( std::exception );

		/**
		 * Create a large object instance if supported by the database.
		 *
		 * @param value Pointer to the content of a field returned by fieldValue()
		 * @return Large object instance
		 * @throws OpenDBX::Exception If the underlying database library returns an error
		 * @see Lob
		 */
		Lob getLob( const char* value ) throw( std::exception );
	};



	/**
	 * Statement object.
	 *
	 * @author Norbert Sendetzky <norbert@linuxnetworks.de>
	 * @version 1.0
	 */
	class Stmt
	{
		friend class Conn;

		/**
		 * Private implementation of object.
		 */
		Stmt_Iface* m_impl;

		/**
		 * Reference counter of copies.
		 */
		int* m_ref;

	protected:

		/**
		 * Default constructor.
		 *
		 * The default constructor isn't part of the public interface as the
		 * object must not be created manually. Instead, the Conn::create()
		 * method is a factory for instances of the Stmt class.
		 *
		 * @return Statement instance
		 */
		Stmt() throw() {};

		/**
		 * Creates a statement instance.
		 *
		 * The constructor isn't part of the public interface as the object must
		 * not be created manually. Instead, the Conn::create()  method is a
		 * factory for instances of the Stmt class.
		 *
		 * @param impl Pointer to private implementation
		 * @throws std::exception If an error occures
		 * @return Statement instance
		 */
		Stmt( Stmt_Iface* impl ) throw( std::exception );

	public:

		/**
		 * Statement objects which can be created.
		 *
		 * Currently, only simple processing of statements is supported which
		 * means that the statement sent to the database server consists of the
		 * statement and the parameters in text form. Later on, also prepared
		 * statements will be available which separates parsing and execution
		 * with different parameters.
		 */
		enum Type { Simple };

		/**
		 * Destroys the statement instance if no other references exist.
		 *
		 * Each statement object uses a reference counter to remember if the
		 * internal variables are shared with other objects. If this isn't the
		 * case or if this object is the last one referencing the variables,
		 * the object is cleanup up and the allocated memory freed.
		 */
		~Stmt() throw();

		/**
		 * Copy constructor.
		 *
		 * Enables the transfer of the internal state of an object of the same
		 * type to this object. Both objects share the same variables
		 * and the reference counter afterwards. The reference counter is
		 * incremented each time an object is copied and will be decremented if
		 * it is destroyed.
		 *
		 * @param ref Original statement object instance
		 */
		Stmt( const Stmt& ref ) throw();

		/**
		 * Assigns a statement instance to another one.
		 *
		 * Assigns the internal state of an object of the same type to this
		 * object. Both objects share the same variables and the
		 * reference counter afterwards. The reference counter is incremented
		 * each time an object is copied and will be decremented if it is
		 * destroyed.
		 *
		 * @param ref Stmt instance
		 * @return Statement reference of this instance
		 */
		Stmt& operator=( const Stmt& ref ) throw();

		/**
		 * Executes a statement and returns a Result instance.
		 *
		 * Sends the necessary data to the database server which will execute
		 * the statement and return one or more result sets afterwards. The
		 * result sets can be fetched via the returned Result object.
		 *
		 * @return Result instance
		 * @throws OpenDBX::Exception If the underlying database library returns an error
		 * @see Result
		 */
		Result execute() throw( std::exception );
	};



	/**
	 * Encapsulates a connection to a database.
	 *
	 * @author Norbert Sendetzky <norbert@linuxnetworks.de>
	 * @version 1.0
	 */
	class Conn
	{
		/**
		 * Private implementation of the connection object.
		 */
		Conn_Iface* m_impl;

		/**
		 * Reference counter of copies.
		 */
		int* m_ref;

	public:

		/**
		 * The default constructor for newly created connection objects without
		 * parameters.
		 *
		 * This is method is provided to enable programmers to use connection
		 * objects as member variables of other classes. They are initialized
		 * at construction time of the encapsulating object when no values
		 * for backend, host and port are available yet.
		 *
		 * It's necessary to replace the created object later on by a connection
		 * instance where the necessary parameters have been given via one of
		 * the other constructors. Calling one of the member functions of an
		 * instance created by the default constructor isn't possible and will
		 * throw an exception.
		 *
		 * @return Empty connection instance
		 * @see #Conn( const char*, const char*, const char* )
		 * @see #Conn( const string&, const string&, const string& )
		 */
		Conn() throw();

		/**
		 * Creates a connection object using C style string parameters.
		 *
		 * Initializes a new connection using the parameters backend, host and
		 * port, but doesn't open the connection to the database yet. This method
		 * allows C style strings as values for all parameters. Another construtor
		 * for C++ style strings is also available. It returns a new connection
		 * instance, which can be used to query options implemented by the driver
		 * or to create a statement. In case of an error, it throws an OpenDBX
		 * exception with error message, code and severity.
		 *
		 * The parameter "backend" is the name of the driver the OpenDBX library
		 * should use to connect to a database. The name must be one of the
		 * implemented and available drivers on the system and is case sensitive.
		 * All driver names are in lower case, e.g. "mysql".
		 *
		 * Depending on the database driver, "host" can have different meanings.
		 * Normally, it's the name or IP address of the server hosting the
		 * database server application. In case of serverless database
		 * implementations like SQLite it's the directory path where the database
		 * file is located. The path must contain the platform specific path
		 * separators like slash ("/") on Unix-like systems and backslash ("\")
		 * on Windows systems. Also the path must end with the path separator
		 * like "/path/to/file/".
		 *
		 * Furthermore "port" can be the number or name the database server
		 * application is listening to. If a name instead of the number is
		 * allowed depends on the database client library but the number as
		 * string does always work. If an empty string is given, the default
		 * port of the database server application is used by the database
		 * client library.
		 *
		 * @param backend Name of the backend module to use
		 * @param host Name or IP address of the database server
		 * @param port Name or number of the port used by the database server
		 * @return Connection instance
		 * @throws std::invalid_argument If the object was only initialized by the default constructor
		 * @throws OpenDBX::Exception If the underlying database library returns an error
		 * @see #Conn( const string&, const string&, const string& )
		 */
		Conn( const char* backend, const char* host = "", const char* port = "" ) throw( std::exception );

		/**
		 * Creates a connection object using C++ style string parameters.
		 *
		 * Initializes a new connection using the parameters backend, host and
		 * port, but doesn't open the connection to the database yet. This method
		 * allows C++ style strings as values for all parameters. Another
		 * construtor for C style strings is also available. It returns a new
		 * connection instance, which can be used to query options implemented
		 * by the driver or to create a statement. In case of an error, it throws
		 * an OpenDBX exception with error message, code and severity.
		 *
		 * The parameter "backend" is the name of the driver the OpenDBX library
		 * should use to connect to a database. The name must be one of the
		 * implemented and available drivers on the system and is case sensitive.
		 * All driver names are in lower case, e.g. "mysql".
		 *
		 * Depending on the database driver, "host" can have different mearings.
		 * Normally, it's the name or IP address of the server hosting the
		 * database server application. In case of serverless database
		 * implementations like SQLite it's the directory path where the database
		 * file is located. The path must contain the platform specific path
		 * separators like slash ("/") on Unix-like systems and backslash ("\")
		 * on Windows systems. Also the path must end with the path separator
		 * like "/path/to/file/".
		 *
		 * Furthermore "port" can be the number or name the database server
		 * application is listening to. If a name instead of the number is
		 * allowed depends on the database client library but the number as
		 * string does always work. If an empty string is given, the default
		 * port of the database server application is used by the database
		 * client library.
		 *
		 * @param backend Name of the backend module to use
		 * @param host Name or IP address of the database server
		 * @param port Name or number of the port used by the database server
		 * @return Connection instance
		 * @throws std::invalid_argument If the object was only initialized by the default constructor
		 * @throws OpenDBX::Exception If the underlying database library returns an error
		 * @see #Conn( const char*, const char*, const char* )
		 */
		Conn( const string& backend, const string& host = "", const string& port = "" ) throw( std::exception );

		/**
		 * Destroys the connection instance if no other references exist.
		 *
		 * Each connection object uses a reference counter to remember if the
		 * connection is shared with other objects. If this isn't the case or
		 * if this object is the last one referencing the connection, the
		 * connection is closed and the allocated memory is freed.
		 */
		~Conn() throw();

		/**
		 * Copy constructor.
		 *
		 * Enables the transfer of the internal state of an object of the same
		 * type to this object. Both objects share the same database connection
		 * and the reference counter afterwards. The reference counter is
		 * incremented each time an object is copied and will be decremented if
		 * it is destroyed.
		 *
		 * @param ref Original connection object instance
		 */
		Conn( const Conn& ref ) throw();

		/**
		 * Assigns a connection instance to another one.
		 *
		 * Assigns the internal state of an object of the same type to this
		 * object. Both objects share the same database connection and the
		 * reference counter afterwards. The reference counter is incremented
		 * each time an object is copied and will be decremented if it is
		 * destroyed.
		 *
		 * @param ref Connection instance
		 * @return Connection reference of this instance
		 */
		Conn& operator=( const Conn& ref ) throw();

		/**
		 * Authenticates the user and selects the database using C style string
		 * parameters.
		 *
		 * After initializing the object instance with one of the constructors
		 * taking a backend, host and port string as parameter, it's necessary
		 * to authenticate the user and select a database. Depending on the
		 * database client library, it also establishes the connection to the
		 * database server. This method accepts C style strings for the database
		 * name, the user name and the password.
		 *
		 * The first parameter, the name of the database will be used to select
		 * the database all further commands are operating on. The database is
		 * the container for the tables, views, etc., which store the records
		 * and provide access to them.
		 *
		 * Authentication is done in most cases by a combination of a user name
		 * and a password. If the user name is known by the database server and
		 * the supplied password matches with the stored one, the database
		 * server will allow the user to operate on the selected database and
		 * its tables provided the user has permissions to read and/or modify
		 * the content.
		 *
		 * The "method" parameter can be used to select different methods of
		 * authentication. At the moment, only simple authentication
		 * (ODBX_BIND_SIMPLE) with user name and password is available.
		 *
		 * @param database Name of the database managed by the database server
		 * @param who Name of the user account known by the database server
		 * @param cred Necessary credential which belongs to the user account
		 * @param method Method used for authentication
		 * @throws std::invalid_argument If the object was only initialized by the default constructor
		 * @throws OpenDBX::Exception If the underlying database library returns an error
		 */
		void bind( const char* database, const char* who = "", const char* cred = "", odbxbind method = ODBX_BIND_SIMPLE ) throw( std::exception );

		/**
		 * Authenticates the user and selects the database using C++ style string
		 * parameters.
		 *
		 * After initializing the object instance with one of the constructors
		 * taking a backend, host and port string as parameter, it's necessary
		 * to authenticate the user and select a database. Depending on the
		 * database client library, it also establishes the connection to the
		 * database server. This method accepts C++ style strings for the
		 * database name, the user name and the password.
		 *
		 * The first parameter, the name of the database will be used to select
		 * the database all further commands are operating on. The database is
		 * the container for the tables, views, etc., which store the records
		 * and provide access to them.
		 *
		 * Authentication is done in most cases by a combination of a user name
		 * and a password. If the user name is known by the database server and
		 * the supplied password matches with the stored one, the database
		 * server will allow the user to operate on the selected database and
		 * its tables provided the user has permissions to read and/or modify
		 * the content.
		 *
		 * The "method" parameter can be used to select different methods of
		 * authentication. At the moment, only simple authentication
		 * (ODBX_BIND_SIMPLE) with user name and password is available.
		 *
		 * @param database Name of the database managed by the database server
		 * @param who Name of the user account known by the database server
		 * @param cred Necessary credential which belongs to the user account
		 * @param method Method used for authentication
		 * @throws std::invalid_argument If the object was only initialized by the default constructor
		 * @throws OpenDBX::Exception If the underlying database library returns an error
		 */
		void bind( const string& database, const string& who = "", const string& cred = "", odbxbind method = ODBX_BIND_SIMPLE ) throw( std::exception );

		/**
		 * Releases the connection to the database and resets the authentication
		 * status.
		 *
		 * @throws std::invalid_argument If the object was only initialized by the default constructor
		 * @throws OpenDBX::Exception If the underlying database library returns an error
		 */
		void unbind() throw( std::exception );

		/**
		 * Cleans up the connection object.
		 *
		 * @throws std::invalid_argument If the object was only initialized by the default constructor
		 * @throws OpenDBX::Exception If the underlying database library returns an error
		 */
		void finish() throw( std::exception );

		/**
		 * Tests if the database driver module does understand certain extensions.
		 *
		 * The OpenDBX library consists of a basic set of functions that must be
		 * implemented by all drivers and optional sets for additional
		 * functionality. This method allows an application to ask the driver
		 * selected by the first parameter of the constructor of this object if
		 * it supports one or more optional sets. The available sets and its
		 * constants are:
		 *
		 * ODBX_CAP_BASIC (basic set supported by all drivers)
		 * ODBX_CAP_LO (special large object handling)
		 *
		 * The basic set makes sure that all drivers can handle connections to
		 * the databases, send statements and retrieve results. It's supported
		 * by all drivers and usually don't have to be checked.
		 *
		 * Some databases client libraries provide the content of large objects
		 * not via the basic functions. Instead, the Result::fieldValue() method
		 * returns only a handle to the large object and reading or modifying
		 * the content of this data object requires calling additional methods.
		 *
		 * @param cap Constant of the capability
		 * @return True if supported, false if not
		 * @throws std::invalid_argument If the object was only initialized by the default constructor
		 * @throws OpenDBX::Exception If the underlying database library returns an error
		 */
		bool getCapability( odbxcap cap ) throw( std::exception );

		/**
		 * Gets the value of a certain option provided by the database driver module.
		 *
		 * @param option Constant of the option
		 * @param value Pointer to memory where the result is stored
		 * @throws std::invalid_argument If the object was only initialized by the default constructor
		 * @throws OpenDBX::Exception If the underlying database library returns an error
		 */
		void getOption( odbxopt option, void* value ) throw( std::exception );

		/**
		 * Sets a certain option provided by the database driver module.
		 *
		 * @param option Constant of the option
		 * @param value Pointer to memory which contains the new value
		 * @throws std::invalid_argument If the object was only initialized by the default constructor
		 * @throws OpenDBX::Exception If the underlying database library returns an error
		 */
		void setOption( odbxopt option, void* value ) throw( std::exception );

		/**
		 * Escapes potentially dangerous characters in user input using a C style buffer.
		 *
		 * For preventing SQL injection attacks which can have desasterous
		 * effects, all text input that will be part of an SQL statement must be
		 * escaped. This does also apply to user content that is already stored
		 * in the database and should be copied to another record or stored
		 * again as the escaping is removed before the database server writes
		 * the content to disk.
		 *
		 * The first parameter must contain the character sequence that should
		 * be escaped as C style string. This string itself won't be modified
		 * by this method.
		 *
		 * The escaped string will be written to the second parameter named
		 * "to", which have to be also an C++ style string. After transforming
		 * the input to an escaped string, the result may be more then twice
		 * the size of the original input. The additional escape sequences
		 * aren't stored in the database column so only the original string will
		 * be written to the disk.
		 *
		 * A C++ reference of the second parameter containing the escaped string
		 * afterwards is also returned by this method to providing the possibility
		 * to write more elegant code.
		 *
		 * @param from Input string with which may contain dangerous characters
		 * @param fromlen Size of the input string to escape in bytes
		 * @param to String instance where the escaped characters should be written to
		 * @return Reference to the second parameter containing the escaped characters
		 * @throws std::invalid_argument If the object was only initialized by the default constructor
		 * @throws OpenDBX::Exception If the underlying database library returns an error
		 */
		string& escape( const char* from, unsigned long fromlen, string& to ) throw( std::exception );

		/**
		 * Escapes potentially dangerous characters in user input using a C++
		 * style string parameter.
		 *
		 * For preventing SQL injection attacks which can have desasterous
		 * effects, all text input that will be part of an SQL statement must be
		 * escaped. This does also apply to user content that is already stored
		 * in the database and should be copied to another record or stored
		 * again as the escaping is removed before the database server writes
		 * the content to disk.
		 *
		 * The first parameter must contain the character sequence that should
		 * be escaped as C++ style string. This string itself won't be modified
		 * by this method.
		 *
		 * The escaped string will be written to the second parameter named
		 * "to", which have to be also an C++ style string. After transforming
		 * the input to an escaped string, the result may be more then twice
		 * the size of the original input. The additional escape sequences
		 * aren't stored in the database column so only the original string will
		 * be written to the disk.
		 *
		 * A C++ reference of the second parameter containing the escaped string
		 * afterwards is also returned by this method to providing the possibility
		 * to write more elegant code.
		 *
		 * @param from Input string with which may contain dangerous characters
		 * @param to String instance where the escaped characters should be written to
		 * @return Reference to the second parameter containing the escaped characters
		 * @throws std::invalid_argument If the object was only initialized by the default constructor
		 * @throws OpenDBX::Exception If the underlying database library returns an error
		 */
		string& escape( const string& from, string& to ) throw( std::exception );

		/**
		 * Creates a statement object from a SQL text string using a C style buffer.
		 *
		 * This method returns an instance of the Stmt class that contains the
		 * statement sent to the database server later on. Currently, only simple
		 * statements are supported, which are sent to the database server for
		 * parsing and returning the result after calling Stmt::execute(). Later
		 * on also prepared statements will be possible which are parsed by the
		 * database server when creating the object and only the parameters
		 * will be sent to the database server on execution. This can speed up
		 * processing especially if the statement is executed multiple times
		 * with different content for the parameters.
		 *
		 * The parameter named "sql" must contain the SQL text string that should be
		 * sent to the database server for execution. It have to be a C style
		 * buffer in this case. For a reference of valid SQL statements, please
		 * have a look at the documentation of your database server.
		 *
		 * The length of the statement excluding the trailing "0" byte should
		 * be given via the second parameter. If the length of the statement is
		 * unknown, you can also supply zero (0) as size value which is also the
		 * default value if you hand over only one parameter. In this case, the
		 * length of the string is calculated internally by this function before
		 * the statement is given to the native database library.
		 *
		 * Via the last parameter it can be selected how the statement should
		 * be treated internally by the OpenDBX and the native database library.
		 * Currently, only simple processing is available which sends complete
		 * SQL statements including its parameters as string to the database
		 * server for parsing and execution. Later on, also prepared statement
		 * handling will be available which parses the statements first and
		 * sends only the parameters to the server before execution. This
		 * parameter is also optional.
		 *
		 * The returned object is representing the given statement, which can
		 * be executed later on. The statement is only valid for the current
		 * connection and as soon as the connection gets invalid or is closed,
		 * working with this object will throw an error.
		 *
		 * @param sql SQL text string containing a valid statement understood by the database server
		 * @param size Size of the SQL text string in bytes
		 * @param type Type of statement object that should be created
		 * @return Statement instance bound to this connection
		 * @throws std::invalid_argument If the object was only initialized by the default constructor
		 * @throws OpenDBX::Exception If the underlying database library returns an error
		 * @see Stmt
		 */
		Stmt create( const char* sql, unsigned long size = 0, Stmt::Type type = Stmt::Simple ) throw( std::exception );

		/**
		 * Creates a statement object from a SQL text string using a C++ string.
		 *
		 * This method returns an instance of the Stmt class that contains the
		 * statement sent to the database server later on. Currently, only simple
		 * statements are supported, which are sent to the database server for
		 * parsing and returning the result after calling Stmt::execute(). Later
		 * on also prepared statements will be possible which are parsed by the
		 * database server when creating the object and only the parameters
		 * will be sent to the database server on execution. This can speed up
		 * processing especially if the statement is executed multiple times
		 * with different content for the parameters.
		 *
		 * The parameter named "sql" must contain the SQL text string that should be
		 * sent to the database server for execution. It have to be a C++ style
		 * string in this case. For a reference of valid SQL statements, please
		 * have a look at the documentation of your database server.
		 *
		 * Via the last parameter it can be selected how the statement should
		 * be treated internally by the OpenDBX and the native database library.
		 * Currently, only simple processing is available which sends complete
		 * SQL statements including its parameters as string to the database
		 * server for parsing and execution. Later on, also prepared statement
		 * handling will be available which parses the statements first and
		 * sends only the parameters to the server before execution. This
		 * parameter is also optional.
		 *
		 * The returned object is representing the given statement, which can
		 * be executed later on. The statement is only valid for the current
		 * connection and as soon as the connection gets invalid or is closed,
		 * working with this object will throw an error.
		 *
		 * @param sql SQL text string containing a valid statement understood by the database server
		 * @param type Type of statement object that should be created
		 * @return Statement instance bound to this connection
		 * @throws std::invalid_argument If the object was only initialized by the default constructor
		 * @throws OpenDBX::Exception If the underlying database library returns an error
		 * @see Stmt
		 */
		Stmt create( const string& sql, Stmt::Type type = Stmt::Simple ) throw( std::exception );
	};



}   // namespace OpenDBX



}   // extern C++



#endif
